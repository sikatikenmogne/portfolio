name: Release Management

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual triggers

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # ===============================================
  # JOB 1: RELEASE PLEASE - Version Management
  # ===============================================
  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    outputs:
      release-created: ${{ steps.release.outputs.release_created }}
      tag-name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.release.outputs.version }}
      upload-url: ${{ steps.release.outputs.upload_url }}
    
    steps:
      - name: Run Release Please
        id: release
        uses: google-github-actions/release-please-action@v4
        with:
          # Point vers le fichier de configuration
          config-file: .release-please-config.json
          # Type de projet (d√©fini aussi dans le config file)
          release-type: node
          
      - name: Log Release Information
        if: steps.release.outputs.release_created
        run: |
          echo "üéâ New release created!"
          echo "Version: ${{ steps.release.outputs.version }}"
          echo "Tag: ${{ steps.release.outputs.tag_name }}"
          echo "Upload URL: ${{ steps.release.outputs.upload_url }}"

  # ===============================================
  # JOB 2: BUILD RELEASE ASSETS (if release created)
  # ===============================================
  build-assets:
    name: Build Release Assets
    runs-on: ubuntu-latest
    needs: release-please
    if: needs.release-please.outputs.release-created
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: '9'
          
      - name: Install dependencies
        run: |
          if [ -f pnpm-lock.yaml ]; then
            pnpm install --frozen-lockfile
          else
            pnpm install --no-frozen-lockfile
          fi
        
      - name: Build production
        run: pnpm run build
        
      - name: Create release archive
        run: |
          # Cr√©er une archive propre du build
          tar -czf "portfolio-${{ needs.release-please.outputs.version }}.tar.gz" \
            .next/ \
            package.json \
            pnpm-lock.yaml \
            README.md \
            LICENSE
            
      - name: Upload release assets
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release-please.outputs.upload-url }}
          asset_path: ./portfolio-${{ needs.release-please.outputs.version }}.tar.gz
          asset_name: portfolio-${{ needs.release-please.outputs.version }}.tar.gz
          asset_content_type: application/gzip

  # ===============================================
  # JOB 3: DEPLOY PRODUCTION (if release created)
  # ===============================================
  deploy-production:
    name: Deploy Production Release
    runs-on: ubuntu-latest
    needs: [release-please, build-assets]
    if: needs.release-please.outputs.release-created
    environment: production
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Deploy to Vercel Production
        uses: amondnet/vercel-action@v25
        id: vercel-production
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./
          
      - name: Update Release with Production URL
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = '${{ needs.release-please.outputs.tag-name }}';
            
            try {
              // R√©cup√©rer la release par tag
              const { data: release } = await github.rest.repos.getReleaseByTag({
                owner,
                repo,
                tag
              });
              
              // Ajouter l'URL de production au body de la release
              const productionUrl = '${{ steps.vercel-production.outputs.preview-url }}';
              const deploymentTime = new Date().toISOString();
              
              const updatedBody = `${release.body}

              ---

              ### üöÄ Production Deployment

              **Live URL**: ${productionUrl}
              **Deployed**: ${deploymentTime}

              ‚úÖ Cette release a √©t√© automatiquement d√©ploy√©e en production.`;
              
              // Mettre √† jour la release
              await github.rest.repos.updateRelease({
                owner,
                repo,
                release_id: release.id,
                body: updatedBody
              });
              
              console.log(`‚úÖ Release ${tag} mise √† jour avec l'URL de production`);
            } catch (error) {
              console.error('Erreur lors de la mise √† jour de la release:', error);
              // Ne pas faire √©chouer le workflow pour cette √©tape
            }

  # ===============================================
  # JOB 4: DEPLOY DIRECT HOTFIX (si pas de release)
  # ===============================================
  deploy-hotfix:
    name: Deploy Hotfix
    runs-on: ubuntu-latest
    needs: release-please
    if: needs.release-please.outputs.release-created != 'true'
    environment: production
    
    steps:
      - name: Log hotfix deployment
        run: |
          echo "üö® D√©ploiement hotfix en production"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Ceci est un push direct sur main (pas via release)"
          
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Deploy to Vercel Production
        uses: amondnet/vercel-action@v25
        id: vercel-hotfix
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./
          
      - name: Create hotfix deployment issue
        uses: actions/github-script@v7
        with:
          script: |
            const commitSha = '${{ github.sha }}';
            const shortSha = commitSha.substring(0, 7);
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Hotfix Deployment - ${shortSha}`,
              body: `## Hotfix Deployment
              
              ### üìã Deployment Details
              - **Commit**: ${shortSha}
              - **Branch**: ${{ github.ref_name }}
              - **Deployed**: ${new Date().toISOString()}
              - **Production URL**: ${{ steps.vercel-hotfix.outputs.preview-url }}
              
              ### ‚ö†Ô∏è Action Required
              - [ ] Verify deployment is working correctly
              - [ ] Monitor for any issues
              - [ ] Create proper release if this fixes critical bugs
              
              ---
              
              Ce d√©ploiement a √©t√© d√©clench√© par un push direct sur main.
              Consid√©rez cr√©er une release appropri√©e si ce hotfix corrige des bugs critiques.
              `,
              labels: ['hotfix', 'deployment', 'production']
            });

  # ===============================================
  # JOB 5: NOTIFICATION & CLEANUP
  # ===============================================
  post-release:
    name: Post-Release Actions
    runs-on: ubuntu-latest
    needs: [release-please, deploy-production]
    if: needs.release-please.outputs.release-created
    
    steps:
      - name: Create Release Summary Issue
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.release-please.outputs.version }}';
            const tag = '${{ needs.release-please.outputs.tag-name }}';
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üéâ Release ${version} Published`,
              body: `## Release ${version} Successfully Published
              
              ### üìã Release Details
              - **Version**: ${version}
              - **Tag**: ${tag}
              - **Release URL**: https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/${tag}
              
              ### ‚úÖ Actions Completed
              - [x] Version calculated from conventional commits
              - [x] CHANGELOG.md updated
              - [x] GitHub release created
              - [x] Production deployment initiated
              - [x] Release assets built and uploaded
              
              ### üîÑ Post-Release Checklist
              - [ ] Verify production deployment
              - [ ] Update documentation if needed
              - [ ] Announce release to team
              - [ ] Monitor for issues
              
              ---
              
              This release was automatically created by Release Please based on conventional commits.
              `,
              labels: ['release', 'published', `v${version}`]
            });
            
      - name: Log Release Summary
        run: |
          echo "üéä Release ${{ needs.release-please.outputs.version }} completed successfully!"
          echo "üì¶ GitHub Release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.release-please.outputs.tag-name }}"
          echo "üöÄ Production deployment in progress..."
